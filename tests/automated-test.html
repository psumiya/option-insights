<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated End-to-End Tests</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #0a0e27;
            color: #e5e7eb;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #3b82f6;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 10px;
        }
        .test-suite {
            margin: 20px 0;
            padding: 15px;
            background: #141b2d;
            border-radius: 8px;
            border-left: 4px solid #6b7280;
        }
        .test-suite.running {
            border-left-color: #3b82f6;
        }
        .test-suite.pass {
            border-left-color: #10b981;
        }
        .test-suite.fail {
            border-left-color: #ef4444;
        }
        .test-case {
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .test-case.pass {
            background: rgba(16, 185, 129, 0.1);
            border-left: 3px solid #10b981;
        }
        .test-case.fail {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
        }
        .test-case.running {
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
        }
        .icon {
            font-size: 18px;
            min-width: 24px;
        }
        .test-name {
            flex: 1;
        }
        .test-duration {
            color: #9ca3af;
            font-size: 12px;
        }
        .error-details {
            margin-top: 8px;
            padding: 10px;
            background: #0a0e27;
            border-radius: 4px;
            font-size: 12px;
            color: #ef4444;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .summary {
            margin-top: 30px;
            padding: 20px;
            background: #141b2d;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        .summary-item {
            text-align: center;
            padding: 15px;
            border-radius: 6px;
        }
        .summary-item.total {
            background: rgba(59, 130, 246, 0.1);
        }
        .summary-item.passed {
            background: rgba(16, 185, 129, 0.1);
        }
        .summary-item.failed {
            background: rgba(239, 68, 68, 0.1);
        }
        .summary-value {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .summary-label {
            font-size: 12px;
            color: #9ca3af;
            text-transform: uppercase;
        }
        .run-button {
            padding: 12px 24px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 20px;
        }
        .run-button:hover {
            background: #2563eb;
        }
        .run-button:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #3b82f6;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª Automated End-to-End Tests</h1>
    
    <button id="run-tests" class="run-button">Run All Tests</button>
    
    <div id="test-results"></div>
    
    <div id="summary" class="summary" style="display: none;">
        <div class="summary-item total">
            <div class="summary-value" id="total-tests">0</div>
            <div class="summary-label">Total Tests</div>
        </div>
        <div class="summary-item passed">
            <div class="summary-value" id="passed-tests">0</div>
            <div class="summary-label">Passed</div>
        </div>
        <div class="summary-item failed">
            <div class="summary-value" id="failed-tests">0</div>
            <div class="summary-label">Failed</div>
        </div>
        <div class="summary-item">
            <div class="summary-value" id="duration">0s</div>
            <div class="summary-label">Duration</div>
        </div>
    </div>

    <!-- Load all application scripts -->
    <script src="../js/broker-adapters.js"></script>
    <script src="../js/csv-parser.js"></script>
    <script src="../js/strategy-detector.js"></script>
    <script src="../js/analytics-engine.js"></script>
    <script src="../js/data-store.js"></script>

    <script>
        class TestRunner {
            constructor() {
                this.results = [];
                this.startTime = null;
            }

            async runAllTests() {
                this.results = [];
                this.startTime = Date.now();
                
                const resultsContainer = document.getElementById('test-results');
                resultsContainer.innerHTML = '';
                
                document.getElementById('run-tests').disabled = true;
                document.getElementById('summary').style.display = 'none';

                // Test suites
                await this.runTestSuite('Core Components', [
                    () => this.testClassesLoaded(),
                    () => this.testBrokerDetection(),
                    () => this.testAdapterCreation()
                ]);

                await this.runTestSuite('Robinhood CSV Parsing', [
                    () => this.testRobinhoodLoad(),
                    () => this.testRobinhoodParsing(),
                    () => this.testRobinhoodDataQuality()
                ]);

                await this.runTestSuite('Tasty CSV Parsing', [
                    () => this.testTastyLoad(),
                    () => this.testTastyParsing(),
                    () => this.testTastyDataQuality()
                ]);

                await this.runTestSuite('Generic CSV Parsing', [
                    () => this.testGenericLoad(),
                    () => this.testGenericParsing(),
                    () => this.testGenericDataQuality()
                ]);

                await this.runTestSuite('Data Processing', [
                    () => this.testStrategyDetection(),
                    () => this.testAnalyticsEnrichment(),
                    () => this.testDataStore()
                ]);

                this.showSummary();
                document.getElementById('run-tests').disabled = false;
            }

            async runTestSuite(name, tests) {
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'test-suite running';
                suiteDiv.innerHTML = `<h3>${name}</h3>`;
                document.getElementById('test-results').appendChild(suiteDiv);

                let allPassed = true;

                for (const test of tests) {
                    const result = await this.runTest(test, suiteDiv);
                    if (!result.passed) allPassed = false;
                }

                suiteDiv.className = `test-suite ${allPassed ? 'pass' : 'fail'}`;
            }

            async runTest(testFn, suiteDiv) {
                const testCase = document.createElement('div');
                testCase.className = 'test-case running';
                testCase.innerHTML = `
                    <span class="icon"><span class="spinner"></span></span>
                    <span class="test-name">Running...</span>
                `;
                suiteDiv.appendChild(testCase);

                const startTime = Date.now();
                let result;

                try {
                    result = await testFn();
                    const duration = Date.now() - startTime;
                    
                    testCase.className = `test-case ${result.passed ? 'pass' : 'fail'}`;
                    testCase.innerHTML = `
                        <span class="icon">${result.passed ? 'âœ“' : 'âœ—'}</span>
                        <span class="test-name">${result.name}</span>
                        <span class="test-duration">${duration}ms</span>
                    `;

                    if (!result.passed && result.error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'error-details';
                        errorDiv.textContent = result.error;
                        testCase.appendChild(errorDiv);
                    }

                    this.results.push(result);
                } catch (error) {
                    const duration = Date.now() - startTime;
                    result = {
                        name: 'Unknown Test',
                        passed: false,
                        error: error.message + '\n' + error.stack
                    };

                    testCase.className = 'test-case fail';
                    testCase.innerHTML = `
                        <span class="icon">âœ—</span>
                        <span class="test-name">Test Error</span>
                        <span class="test-duration">${duration}ms</span>
                    `;

                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-details';
                    errorDiv.textContent = result.error;
                    testCase.appendChild(errorDiv);

                    this.results.push(result);
                }

                return result;
            }

            showSummary() {
                const duration = ((Date.now() - this.startTime) / 1000).toFixed(2);
                const total = this.results.length;
                const passed = this.results.filter(r => r.passed).length;
                const failed = total - passed;

                document.getElementById('total-tests').textContent = total;
                document.getElementById('passed-tests').textContent = passed;
                document.getElementById('failed-tests').textContent = failed;
                document.getElementById('duration').textContent = duration + 's';
                document.getElementById('summary').style.display = 'grid';
            }

            // Test Cases

            testClassesLoaded() {
                const checks = [
                    { name: 'BrokerAdapter', exists: typeof BrokerAdapter !== 'undefined' },
                    { name: 'RobinhoodAdapter', exists: typeof RobinhoodAdapter !== 'undefined' },
                    { name: 'TastyAdapter', exists: typeof TastyAdapter !== 'undefined' },
                    { name: 'GenericAdapter', exists: typeof GenericAdapter !== 'undefined' },
                    { name: 'CSVParser', exists: typeof CSVParser !== 'undefined' },
                    { name: 'StrategyDetector', exists: typeof StrategyDetector !== 'undefined' },
                    { name: 'AnalyticsEngine', exists: typeof AnalyticsEngine !== 'undefined' },
                    { name: 'DataStore', exists: typeof DataStore !== 'undefined' }
                ];

                const missing = checks.filter(c => !c.exists).map(c => c.name);

                return {
                    name: 'All core classes loaded',
                    passed: missing.length === 0,
                    error: missing.length > 0 ? `Missing classes: ${missing.join(', ')}` : null
                };
            }

            testBrokerDetection() {
                const tests = [
                    {
                        name: 'Robinhood',
                        headers: ['Activity Date', 'Trans Code', 'Instrument'],
                        expected: 'robinhood'
                    },
                    {
                        name: 'Tasty',
                        headers: ['MarketOrFill', 'TimeStampAtType', 'Order #'],
                        expected: 'tasty'
                    },
                    {
                        name: 'Generic',
                        headers: ['Symbol', 'Entry', 'Credit'],
                        expected: 'generic'
                    }
                ];

                for (const test of tests) {
                    const detected = BrokerAdapter.detectBroker(test.headers, []);
                    if (detected !== test.expected) {
                        return {
                            name: 'Broker format detection',
                            passed: false,
                            error: `${test.name}: Expected '${test.expected}', got '${detected}'`
                        };
                    }
                }

                return {
                    name: 'Broker format detection',
                    passed: true
                };
            }

            testAdapterCreation() {
                try {
                    const rh = BrokerAdapter.getAdapter('robinhood');
                    const tasty = BrokerAdapter.getAdapter('tasty');
                    const generic = BrokerAdapter.getAdapter('generic');

                    if (!rh || !tasty || !generic) {
                        return {
                            name: 'Adapter creation',
                            passed: false,
                            error: 'One or more adapters failed to create'
                        };
                    }

                    return {
                        name: 'Adapter creation',
                        passed: true
                    };
                } catch (error) {
                    return {
                        name: 'Adapter creation',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testRobinhoodLoad() {
                try {
                    const response = await fetch('../sample-data/Hood.csv');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const text = await response.text();
                    
                    return {
                        name: 'Load Robinhood CSV file',
                        passed: text.length > 0,
                        error: text.length === 0 ? 'File is empty' : null
                    };
                } catch (error) {
                    return {
                        name: 'Load Robinhood CSV file',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testRobinhoodParsing() {
                try {
                    const response = await fetch('../sample-data/Hood.csv');
                    const text = await response.text();
                    
                    const parser = new CSVParser();
                    const trades = parser.parseCSVString(text);
                    
                    return {
                        name: `Parse Robinhood CSV (${trades.length} trades)`,
                        passed: trades.length > 0,
                        error: trades.length === 0 ? 'No trades parsed' : null
                    };
                } catch (error) {
                    return {
                        name: 'Parse Robinhood CSV',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testRobinhoodDataQuality() {
                try {
                    const response = await fetch('../sample-data/Hood.csv');
                    const text = await response.text();
                    
                    const parser = new CSVParser();
                    const trades = parser.parseCSVString(text);
                    
                    // Check data quality
                    const issues = [];
                    
                    trades.forEach((trade, i) => {
                        if (!trade.Symbol) issues.push(`Trade ${i}: Missing Symbol`);
                        if (!trade.Entry) issues.push(`Trade ${i}: Missing Entry`);
                        if (trade.Credit === undefined) issues.push(`Trade ${i}: Missing Credit`);
                        if (trade.Debit === undefined) issues.push(`Trade ${i}: Missing Debit`);
                    });
                    
                    return {
                        name: 'Robinhood data quality check',
                        passed: issues.length === 0,
                        error: issues.length > 0 ? issues.slice(0, 5).join('\n') : null
                    };
                } catch (error) {
                    return {
                        name: 'Robinhood data quality check',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testTastyLoad() {
                try {
                    const response = await fetch('../sample-data/Tasty.csv');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const text = await response.text();
                    
                    return {
                        name: 'Load Tasty CSV file',
                        passed: text.length > 0,
                        error: text.length === 0 ? 'File is empty' : null
                    };
                } catch (error) {
                    return {
                        name: 'Load Tasty CSV file',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testTastyParsing() {
                try {
                    const response = await fetch('../sample-data/Tasty.csv');
                    const text = await response.text();
                    
                    const parser = new CSVParser();
                    const trades = parser.parseCSVString(text);
                    
                    return {
                        name: `Parse Tasty CSV (${trades.length} trades)`,
                        passed: trades.length > 0,
                        error: trades.length === 0 ? 'No trades parsed' : null
                    };
                } catch (error) {
                    return {
                        name: 'Parse Tasty CSV',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testTastyDataQuality() {
                try {
                    const response = await fetch('../sample-data/Tasty.csv');
                    const text = await response.text();
                    
                    const parser = new CSVParser();
                    const trades = parser.parseCSVString(text);
                    
                    const issues = [];
                    
                    trades.forEach((trade, i) => {
                        if (!trade.Symbol) issues.push(`Trade ${i}: Missing Symbol`);
                        if (!trade.Entry) issues.push(`Trade ${i}: Missing Entry`);
                    });
                    
                    return {
                        name: 'Tasty data quality check',
                        passed: issues.length === 0,
                        error: issues.length > 0 ? issues.slice(0, 5).join('\n') : null
                    };
                } catch (error) {
                    return {
                        name: 'Tasty data quality check',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testGenericLoad() {
                try {
                    const response = await fetch('../sample-data/sample-data-messy.csv');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const text = await response.text();
                    
                    return {
                        name: 'Load Generic CSV file',
                        passed: text.length > 0,
                        error: text.length === 0 ? 'File is empty' : null
                    };
                } catch (error) {
                    return {
                        name: 'Load Generic CSV file',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testGenericParsing() {
                try {
                    const response = await fetch('../sample-data/sample-data-messy.csv');
                    const text = await response.text();
                    
                    const parser = new CSVParser();
                    const trades = parser.parseCSVString(text);
                    
                    return {
                        name: `Parse Generic CSV (${trades.length} trades)`,
                        passed: trades.length > 0,
                        error: trades.length === 0 ? 'No trades parsed' : null
                    };
                } catch (error) {
                    return {
                        name: 'Parse Generic CSV',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testGenericDataQuality() {
                try {
                    const response = await fetch('../sample-data/sample-data-messy.csv');
                    const text = await response.text();
                    
                    const parser = new CSVParser();
                    const trades = parser.parseCSVString(text);
                    
                    const issues = [];
                    
                    trades.forEach((trade, i) => {
                        if (!trade.Symbol) issues.push(`Trade ${i}: Missing Symbol`);
                        if (!trade.Entry) issues.push(`Trade ${i}: Missing Entry`);
                    });
                    
                    return {
                        name: 'Generic data quality check',
                        passed: issues.length === 0,
                        error: issues.length > 0 ? issues.slice(0, 5).join('\n') : null
                    };
                } catch (error) {
                    return {
                        name: 'Generic data quality check',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testStrategyDetection() {
                try {
                    const detector = new StrategyDetector();
                    const testTrade = {
                        Strategy: 'Bull Call Spread',
                        Type: 'Call'
                    };
                    
                    const detected = detector.detect(testTrade);
                    
                    return {
                        name: 'Strategy detection',
                        passed: detected === 'Bull Call Spread',
                        error: detected !== 'Bull Call Spread' ? `Expected 'Bull Call Spread', got '${detected}'` : null
                    };
                } catch (error) {
                    return {
                        name: 'Strategy detection',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testAnalyticsEnrichment() {
                try {
                    const engine = new AnalyticsEngine();
                    const testTrade = {
                        Symbol: 'AAPL',
                        Entry: new Date('2024-01-01'),
                        Exit: new Date('2024-01-15'),
                        Expiry: new Date('2024-02-01'),
                        Credit: 100,
                        Debit: 50
                    };
                    
                    const enriched = engine.enrichTrade(testTrade);
                    
                    const checks = [
                        enriched.ProfitLoss === 50,
                        enriched.DaysHeld === 14,
                        enriched.Result === 'Win'
                    ];
                    
                    return {
                        name: 'Analytics enrichment',
                        passed: checks.every(c => c),
                        error: !checks.every(c => c) ? 'Enrichment calculations incorrect' : null
                    };
                } catch (error) {
                    return {
                        name: 'Analytics enrichment',
                        passed: false,
                        error: error.message
                    };
                }
            }

            async testDataStore() {
                try {
                    const store = new DataStore();
                    
                    // Test save and load
                    const testTrades = [
                        { Symbol: 'TEST', Entry: new Date(), Credit: 100, Debit: 50 }
                    ];
                    
                    store.saveTrades(testTrades);
                    const loaded = store.loadTrades();
                    
                    // Clean up
                    store.clearTrades();
                    
                    return {
                        name: 'DataStore save/load',
                        passed: loaded.length === 1 && loaded[0].Symbol === 'TEST',
                        error: loaded.length !== 1 ? 'Failed to save/load trades' : null
                    };
                } catch (error) {
                    return {
                        name: 'DataStore save/load',
                        passed: false,
                        error: error.message
                    };
                }
            }
        }

        // Initialize test runner
        const runner = new TestRunner();

        document.getElementById('run-tests').addEventListener('click', () => {
            runner.runAllTests();
        });

        // Auto-run on load
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => runner.runAllTests(), 500);
        });
    </script>
</body>
</html>
